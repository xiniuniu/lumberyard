/*
* All or portions of this file Copyright (c) Amazon.com, Inc. or its affiliates or
* its licensors.
*
* For complete copyright and license terms please see the LICENSE at the root of this
* distribution (the "License"). All use of this software is governed by the License,
* or, if provided, by the license below or the license accompanying this file. Do not
* remove or modify any license notices. This file is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*
*/
#pragma once

#include <IMaterial.h>
#include <gmock/gmock.h>

// the following was generated using google's python script to autogenerate mocks.
// however, it needed some hand-editing to make it work, so if you add functions to IMaterialManager,
// it will probably be better to just manually add them here than try to run the script again.

#if defined(AZ_COMPILER_MSVC) 
    // 4373 is generated by google mock on VS2015 only.  It warns that this code is not going to compile
    // on VS2013 and earlier.  Becuase VS2015 was a transitionary VS, MS added a bunch of warnings like this, 
    // warning developers when they were writing code that would not be backwards compatible with the non-standard
    // VS2013 and earlier.  Google mock generates code that falls in this category but this is something we can
    // safely ignore, as our software is for versions later than that.
    #pragma warning(push)
    #pragma warning(disable:4373) 
#endif // AZ_COMPILER_MSVC

class IMaterialManagerMock 
    : public IMaterialManager 
{
public:
    MOCK_CONST_METHOD1(GetMemoryUsage,
        void(ICrySizer* pSizer));
    MOCK_METHOD2(CreateMaterial,
        _smart_ptr<IMaterial>(const char* sMtlName, int nMtlFlags));
    MOCK_METHOD2(RenameMaterial,
        void(_smart_ptr<IMaterial> pMtl, const char* sNewName));
    MOCK_CONST_METHOD1(FindMaterial,
        _smart_ptr<IMaterial>(const char* sMtlName));
    MOCK_METHOD4(LoadMaterial,
        _smart_ptr<IMaterial>(const char* sMtlName, bool bMakeIfNotFound, bool bNonremovable, unsigned long nLoadingFlags));
    MOCK_METHOD2(LoadMaterialFromXml,
        _smart_ptr<IMaterial>(const char* sMtlName, XmlNodeRef mtlNode));
    MOCK_METHOD1(ReloadMaterial,
        void(_smart_ptr<IMaterial> pMtl));
    MOCK_METHOD2(SaveMaterial,
        bool(XmlNodeRef mtlNode, _smart_ptr<IMaterial> pMtl));
    MOCK_METHOD2(CloneMaterial,
        _smart_ptr<IMaterial>(_smart_ptr<IMaterial> pMtl, int nSubMtl));
    MOCK_METHOD3(CopyMaterial,
        void(_smart_ptr<IMaterial> pMtlSrc, _smart_ptr<IMaterial> pMtlDest, EMaterialCopyFlags flags));
    MOCK_METHOD2(CloneMultiMaterial,
        _smart_ptr<IMaterial>(_smart_ptr<IMaterial> pMtl, const char* sSubMtlName));
    MOCK_METHOD1(SetListener,
        void(IMaterialManagerListener* pListener));
    MOCK_METHOD0(GetDefaultMaterial,
        _smart_ptr<IMaterial>());
    MOCK_METHOD0(GetDefaultTerrainLayerMaterial,
        _smart_ptr<IMaterial>());
    MOCK_METHOD0(GetDefaultLayersMaterial,
        _smart_ptr<IMaterial>());
    MOCK_METHOD0(GetDefaultHelperMaterial,
        _smart_ptr<IMaterial>());
    MOCK_METHOD2(GetSurfaceTypeByName,
        ISurfaceType*(const char* sSurfaceTypeName, const char* sWhy));
    MOCK_METHOD2(GetSurfaceTypeIdByName,
        int(const char* sSurfaceTypeName, const char* sWhy));
    MOCK_METHOD2(GetSurfaceType,
        ISurfaceType*(int nSurfaceTypeId, const char* sWhy));
    MOCK_METHOD0(GetSurfaceTypeManager,
        ISurfaceTypeManager*());
    MOCK_METHOD3(LoadCGFMaterial,
        _smart_ptr<IMaterial>(CMaterialCGF* pMaterialCGF, const char* sCgfFilename, unsigned long nLoadingFlags));
    MOCK_CONST_METHOD2(GetLoadedMaterials,
        void(std::vector<_smart_ptr<IMaterial>>* pData, uint32& nObjCount));
    MOCK_METHOD0(RefreshMaterialRuntime,
        void());
};

class IMaterialMock 
    : public IMaterial 
{
public:
    MOCK_METHOD0(AddRef,
        void());
    MOCK_METHOD0(Release,
        void());
    MOCK_METHOD0(GetNumRefs,
        int());
    MOCK_METHOD0(GetMaterialHelpers,
        IMaterialHelpers&());
    MOCK_METHOD0(GetMaterialManager,
        IMaterialManager*());
    MOCK_METHOD1(SetName,
        void(const char* pName));
    MOCK_CONST_METHOD0(GetName,
        const char*());
    MOCK_METHOD1(SetShaderName,
        void(const char* pName));
    MOCK_CONST_METHOD0(GetShaderName,
        const char*());
    MOCK_METHOD1(SetFlags,
        void(int flags));
    MOCK_CONST_METHOD0(GetFlags,
        int());
    MOCK_METHOD0(UpdateFlags,
        void());
    MOCK_METHOD0(IsDefault,
        bool());
    MOCK_METHOD0(GetSurfaceTypeId,
        int());
    MOCK_METHOD1(SetSurfaceType,
        void(const char* sSurfaceTypeName));
    MOCK_METHOD0(GetSurfaceType,
        ISurfaceType*());
    MOCK_METHOD0(ReleaseCurrentShaderItem,
        void());
    MOCK_METHOD1(SetShaderItem,
        void(const SShaderItem& _ShaderItem));
    MOCK_METHOD1(AssignShaderItem,
        void(const SShaderItem& _ShaderItem));
    MOCK_METHOD0(GetShaderItem,
        SShaderItem&());
    MOCK_CONST_METHOD0(GetShaderItem,
        const SShaderItem&());
    MOCK_METHOD1(GetShaderItem,
        SShaderItem&(int nSubMtlSlot));
    MOCK_CONST_METHOD1(GetShaderItem,
        const SShaderItem&(int nSubMtlSlot));
    MOCK_CONST_METHOD2(IsStreamedIn,
        bool(const int nMinPrecacheRoundIds[MAX_STREAM_PREDICTION_ZONES], IRenderMesh* pRenderMesh));
    MOCK_METHOD1(SetSubMtlCount,
        void(int numSubMtl));
    MOCK_METHOD0(GetSubMtlCount,
        int());
    MOCK_METHOD1(GetSubMtl,
        _smart_ptr<IMaterial>(int nSlot));
    MOCK_METHOD2(SetSubMtl,
        void(int nSlot, _smart_ptr<IMaterial> pMtl));
    MOCK_METHOD1(SetLayerCount,
        void(uint32 nCount));
    MOCK_CONST_METHOD0(GetLayerCount,
        uint32());
    MOCK_METHOD2(SetLayer,
        void(uint32 nSlot, IMaterialLayer* pLayer));
    MOCK_CONST_METHOD2(GetLayer,
        const IMaterialLayer*(uint8 nLayersMask, uint8 nLayersUsageMask));
    MOCK_CONST_METHOD1(GetLayer,
        const IMaterialLayer*(uint32 nSlot));
    MOCK_METHOD0(CreateLayer,
        IMaterialLayer*());
    MOCK_METHOD1(GetSafeSubMtl,
        _smart_ptr<IMaterial>(int nSlot));
    MOCK_METHOD1(FillSurfaceTypeIds,
        int(int pSurfaceIdsTable[]));
    MOCK_METHOD1(SetUserData,
        void(void* pUserData));
    MOCK_CONST_METHOD0(GetUserData,
        void*());
    MOCK_METHOD5(SetGetMaterialParamFloat,
        bool(const char* sParamName, float& v, bool bGet, bool allowShaderParam, int materialIndex));
    MOCK_METHOD5(SetGetMaterialParamVec3,
        bool(const char* sParamName, Vec3& v, bool bGet, bool allowShaderParam, int materialIndex));
    MOCK_METHOD5(SetGetMaterialParamVec4,
        bool(const char* sParamName, Vec4& v, bool bGet, bool allowShaderParam, int materialIndex));
    MOCK_METHOD1(SetDirty,
        void(bool dirty));
    MOCK_CONST_METHOD0(IsDirty,
        bool());
    MOCK_CONST_METHOD0(IsMaterialGroup,
        bool());
    MOCK_CONST_METHOD0(IsSubMaterial,
        bool());
    MOCK_CONST_METHOD1(GetMemoryUsage,
        void(ICrySizer* pSizer));
    MOCK_METHOD1(GetResourceMemoryUsage,
        size_t(ICrySizer* pSizer));
    MOCK_METHOD1(SetSketchMode,
        void(int mode));
    MOCK_METHOD0(GetLoadingCallstack,
        const char*());
    MOCK_METHOD0(DisableTextureStreaming,
        void());
    MOCK_METHOD1(RequestTexturesLoading,
        void(const float fMipFactor));
    MOCK_METHOD4(PrecacheMaterial,
        void(const float fEntDistance, struct IRenderMesh* pRenderMesh, bool bFullUpdate, bool bDrawNear));
    MOCK_METHOD2(GetTextureMemoryUsage,
        int(ICrySizer* pSizer, int nMatID));
    MOCK_METHOD1(SetMaterialLinkName,
        void(const char* name));
    MOCK_CONST_METHOD0(GetMaterialLinkName,
        const char*());
    MOCK_METHOD0(SetKeepLowResSysCopyForDiffTex,
        void());
    MOCK_CONST_METHOD0(GetDccMaterialHash,
        uint32());
    MOCK_METHOD1(SetDccMaterialHash,
        void(uint32 hash));
    MOCK_METHOD0(GetSubMaterialResizeLock,
        CryCriticalSection&());
};

#if defined(AZ_COMPILER_MSVC) 
    #pragma warning(pop)
#endif // AZ_COMPILER MSVC

