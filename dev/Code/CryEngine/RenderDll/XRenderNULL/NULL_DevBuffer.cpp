/*
* All or portions of this file Copyright (c) Amazon.com, Inc. or its affiliates or
* its licensors.
*
* For complete copyright and license terms please see the LICENSE at the root of this
* distribution (the "License"). All use of this software is governed by the License,
* or, if provided, by the license below or the license accompanying this file. Do not
* remove or modify any license notices. This file is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*
*/
// Original file Copyright Crytek GMBH or its affiliates, used under license.

#include "StdAfx.h"

//////////////////////////////////////////////////////////////////////////////////////
buffer_handle_t CDeviceBufferManager::Create_Locked(BUFFER_BIND_TYPE, BUFFER_USAGE, size_t)
{
    return buffer_handle_t();
}

//////////////////////////////////////////////////////////////////////////////////////
void CDeviceBufferManager::Destroy_Locked(buffer_handle_t)
{
}

//////////////////////////////////////////////////////////////////////////////////////
void* CDeviceBufferManager::BeginRead_Locked(buffer_handle_t handle)
{
    return nullptr;
}

//////////////////////////////////////////////////////////////////////////////////////
void* CDeviceBufferManager::BeginWrite_Locked(buffer_handle_t handle)
{
    return nullptr;
}

//////////////////////////////////////////////////////////////////////////////////////
void CDeviceBufferManager::EndReadWrite_Locked(buffer_handle_t handle)
{
}

//////////////////////////////////////////////////////////////////////////////////////
bool CDeviceBufferManager::UpdateBuffer_Locked(buffer_handle_t handle, const void*, size_t)
{
    return false;
}

//////////////////////////////////////////////////////////////////////////////////////
size_t CDeviceBufferManager::Size_Locked(buffer_handle_t)
{
    return 0;
}

//////////////////////////////////////////////////////////////////////////////////////
CDeviceBufferManager::CDeviceBufferManager()
{
}

//////////////////////////////////////////////////////////////////////////////////////
CDeviceBufferManager::~CDeviceBufferManager()
{
}

//////////////////////////////////////////////////////////////////////////////////////
void CDeviceBufferManager::LockDevMan()
{
}

//////////////////////////////////////////////////////////////////////////////////////
void CDeviceBufferManager::UnlockDevMan()
{
}

//////////////////////////////////////////////////////////////////////////////////////
bool CDeviceBufferManager::Init()
{
    return true;
}

//////////////////////////////////////////////////////////////////////////////////////
bool CDeviceBufferManager::Shutdown()
{
    return true;
}

//////////////////////////////////////////////////////////////////////////////////////
void CDeviceBufferManager::Sync(uint32 framdid)
{
}

//////////////////////////////////////////////////////////////////////////////////////
void CDeviceBufferManager::Update(uint32, bool called_during_loading)
{
}

//////////////////////////////////////////////////////////////////////////////////////
buffer_handle_t CDeviceBufferManager::Create(
    BUFFER_BIND_TYPE type
    , BUFFER_USAGE usage
    , size_t size)
{
    return ~0u;
}

//////////////////////////////////////////////////////////////////////////////////////
void CDeviceBufferManager::Destroy(buffer_handle_t handle)
{
}

//////////////////////////////////////////////////////////////////////////////////////
void* CDeviceBufferManager::BeginRead(buffer_handle_t handle)
{
    return NULL;
}

//////////////////////////////////////////////////////////////////////////////////////
void* CDeviceBufferManager::BeginWrite(buffer_handle_t handle)
{
    return NULL;
}

//////////////////////////////////////////////////////////////////////////////////////
void CDeviceBufferManager::EndReadWrite(buffer_handle_t handle)
{
}

//////////////////////////////////////////////////////////////////////////////////////
bool CDeviceBufferManager::UpdateBuffer(buffer_handle_t handle, const void* src, size_t size)
{
    return true;
}

/////////////////////////////////////////////////////////////
// Legacy interface
//
// Use with care, can be removed at any point!
//////////////////////////////////////////////////////////////////////////////////////
void CDeviceBufferManager::ReleaseVBuffer(CVertexBuffer* pVB)
{
    SAFE_DELETE(pVB);
}
//////////////////////////////////////////////////////////////////////////////////////
void CDeviceBufferManager::ReleaseIBuffer(CIndexBuffer* pIB)
{
    SAFE_DELETE(pIB);
}
//////////////////////////////////////////////////////////////////////////////////////
CVertexBuffer* CDeviceBufferManager::CreateVBuffer(size_t nVerts, const AZ::Vertex::Format& vertexFormat, const char* szName, BUFFER_USAGE usage)
{
    CVertexBuffer* pVB = new CVertexBuffer(NULL, vertexFormat);
    return pVB;
}
//////////////////////////////////////////////////////////////////////////////////////
CIndexBuffer* CDeviceBufferManager::CreateIBuffer(size_t nInds, const char* szNam, BUFFER_USAGE usage)
{
    CIndexBuffer* pIB = new CIndexBuffer(NULL);
    return pIB;
}
//////////////////////////////////////////////////////////////////////////////////////
bool CDeviceBufferManager::UpdateVBuffer(CVertexBuffer* pVB, void* pVerts, size_t nVerts)
{
    return true;
}
//////////////////////////////////////////////////////////////////////////////////////
bool CDeviceBufferManager::UpdateIBuffer(CIndexBuffer* pIB, void* pInds, size_t nInds)
{
    return true;
}
//////////////////////////////////////////////////////////////////////////////////////
CVertexBuffer::~CVertexBuffer()
{
}
//////////////////////////////////////////////////////////////////////////////////////
CIndexBuffer::~CIndexBuffer()
{
}

namespace AzRHI
{
    ConstantBuffer::~ConstantBuffer()
    {}

    void ConstantBuffer::AddRef()
    {}

    AZ::u32 ConstantBuffer::Release()
    {
        return 0;
    }
}